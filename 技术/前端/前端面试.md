## Javascript

### 数据类型
* 基本数据类型
`Null Undefined Number Boolean String Symbol (ES6)`
* 引用数据类型
`Object`
> 注：其中，Function, Data, Array 等都属于 Object 类型。

### 类型判断
#### typeof
用于判断基本数据类型
```js
// 基本类型
typeof 2; // 'number'
typeof 'hello'; // 'string'
typeof false; // 'boolean'
typeof undefined; // 'undefined'
typeof Symbol(); // 'symbol'
typeof null; // 'object'

// 引用类型
typeof {}; // 'object'
typeof function () {}; // 'function'
// ... 其他都是 'object'

```
#### instanceof
可用于判断对象实例，进而判断非基本数据类型
#### Object.prototype.toString.call
可得到变量内部具体类型字符串
```js
Object.prototype.toString.call(1); // "[object Number]"
Object.prototype.toString.call('sss'); // "[object String]"
Object.prototype.toString.call(null); // "[object Null]"
```

### let 与 var
1. 不存在变量提升
2. 具有块作用域
3. 不允许重复声明
4. 存在暂时性死区（TDZ）

### 数组去重
#### Set
```js
const arr = [1, 2, 3, 3, 4, 5];
[...new Set(arr)]
```
#### filter
```js
arr.filter((item, index, array) => {
    return index === array.indexOf(item);
});
```

### 原生 Ajax 请求
```js
const req;
const url = "https://www.google.com";

if(window.XMLHttpRequest){
    req = new window.XMLHttpRequest();
}else {
    req = ActiveXObject("Microsoft.XMLHTTP");
}
req.onreadystatechange = function(){
    if(req.readyState === 4 && req.status === 200){
        // do something
    }
}
req.open("GET", url, true);
req.setRequestHeader("Content-Type", "application/json");
req.send(/*data*/);
```
readyState 有五种状态
* 0 请求未打开
* 1 请求未发送
* 2 请求已发送，正在获取响应头
* 3 正在下载响应体
* 4 请求完成

req.abort()  可用于发送过程中终止请求。

### JS 导致内存泄漏常见原因
1. 闭包使用不当
2. 未分离被引用的 dom 节点
3. 事件绑定未移除

《了解 JavaScript 应用程序中的内存泄漏》https://www.ibm.com/developerworks/cn/web/wa-jsmemory/

### 如何实现函数的自调用？
1. 命名函数直接使用函数名
2. 命名或者匿名函数都可以使用 argument.callee() 自调用

### 简述严格模式与非严格模式的区别。
1. 未使用 var 声明的变量会直接报错，而不是定义为全局变量。

### 如何判断一个变量是否存在？如何区别变量未声明和已声明但未定义？
使用 typeof 判断未存在的变量得到 undefined，不会报错。

### 简述真值与假值
除了 false, 0, null, undefined, ''（空字符串）, NaN（非法数字）
其他认为是真值。

### 如何获取当前时间的时间戳？
1. new Date('1990-12-19').getTime()
2. new Date('1990-12-19').valueOf()
3. -(-new Date('1990-12-19'))
4. +new Date()

### 类型转换

### 防抖与节流

### call, apply, bind

### 浅拷贝与深拷贝
#### 浅拷贝
1. 简单 for 循环拷贝对象第一层
2. 使用 Object.assign 进行拷贝
3. 使用扩展运算符 ... 进行拷贝
```js
const a = {
  x: 'xxx'
};
// Object.assign
const b = Object.assign({}, a);
// 扩展运算符
const b = {...a};
```
#### 深拷贝
1. 对对象进行递归循环拷贝。
2. 使用 JSON.parse(JSON.string(obj)) 进行拷贝
该办法缺点（会报错）：
* 会忽略 undefined
* 会忽略 symbol
* 不能序列化函数
* 不能解决循环引用的对象
```js
const a = {
  a1: {
    a11: 1,
    a12: 'xx'
  },
  a2: 'ss'
};

const b = JSON.parse(JSON.stringify(a));
```

### 原型与原型链

### this 执行上下文

### Promise 的实现

### 闭包

### 变量提升

### 宽松相等 == 与 严格相等 ===

### 模块化
CommonJS
ES6 Import/Export
AMD



## CSS


## 浏览器
### HTTP 状态码
* 1xx 正在请求
* 2xx 请求成功信息
* 3xx 重定向信息<br>
  301 永久移动，网页已被永久移动到其他位置<br>
  303 重定向到其他地址<br>
  304 未修改，自上次请求，网页未被修改，不返回网页内容<br>
* 4xx 客户端请求出错<br>
  401 未授权<br>
  403 被禁止<br>
  404 未找到<br>
  405 请求方法被禁止<br>
* 5xx 服务器错误<br>
  500 服务器内部错误<br>
  503 服务不可用<br>
  504 网关出错或不可用<br>
  
### 跨域
什么是同源策略？
> 同源策略：浏览器出于安全考虑，禁止不同协议，不同域名，不同端口之间互相操作 cookie, dom 以及发起 ajax 请求等。

解决跨域问题主要有以下方法：

#### JSONP
有局限性：1. 只能使用 GET 请求 2. 请求参数由于 url 长度而受限 3. 前后端强耦合

#### CORS
IE >= 10

《跨域资源共享 CORS 详解》http://www.ruanyifeng.com/blog/2016/04/cors.html

#### 服务器代理转发请求
其它，比如 window.name, postMessage, window,origin 等


### 存储
#### cookie
大小受限，最大4k，可设置存储过期时间等，缺点在于每次请求都会被带上给服务器，适合关键小量信息。
#### session
服务端存储的会话信息
#### sessionStorage
页面级别的存储，当关闭页面时存储被销毁，最大 5M。
#### alStorage
浏览器可持久化的存储方式，除非清理，否则一直存在，最大 5M。

### 事件绑定
* 直接在 html 标签上使用事件绑定，例如
```htlm
<button onclick="onLogin"></button>
```
* 获取元素并直接设置
```js
var btn = document.getElementById('login-btn');
btn.onclick = function (event) {
 // do something
}
```
* 低版本 IE 浏览器下使用 document.attachEvent()
* 其他浏览器环境使用 document.addEventListener()

### event.target 和 event.currentTarget 的区别
event.target 指向事件触发的元素

event.currentTarget 指向事件绑定的元素

例如，事件绑定在 ul 上，触发的却是 li


## Vue
### vue 双向绑定是基于什么原理？
Object.defineProperty 的 getter , setter 对数据进行依赖收集

### Vue 有哪些生命周期函数？
`beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestroy, destroyed, activated, deactivated`


## 算法
### 设计模式
#### 工厂模式
#### 单例模式
#### 适配器模式
#### 装饰模式
#### 代理模式
#### 发布订阅模式
