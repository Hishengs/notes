# V8 下的垃圾回收机制

## 代际假说和分代收集

在正式介绍 V8 是如何实现回收之前，你需要先学习下代际假说（The Generational Hypothesis）的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。

代际假说有以下两个特点：

第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；

第二个是不死的对象，会活得更久。

其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的动态语言，如 Java、Python 等。

有了代际假说的基础，我们就可以来探讨 V8 是如何实现垃圾回收的了。

通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。

所以，在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

副垃圾回收器，主要负责新生代的垃圾回收。
主垃圾回收器，主要负责老生代的垃圾回收。

## 垃圾回收器的工作流程

现在你知道了 V8 把堆分成两个区域——新生代和老生代，并分别使用两个不同的垃圾回收器。其实不论什么类型的垃圾回收器，它们都有一套共同的执行流程。

第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。

第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

那么接下来，我们就按照这个流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。

## 分代垃圾回收

v8 `GC` 算法方面采用了分代垃圾回收，结构如下
![image](https://user-images.githubusercontent.com/8407978/160434389-736bb0ed-a71a-4178-8b09-c4b4a8094f18.png)

### 复制算法（By Cheney）

`GC` 复制算法将内存空间分为 `From` 和 `To`，当 `From` 空间占满时，将 `From` 空间中的活动对象（划重点）复制到 `To` 空间中，非活动对象回收掉，然后 `From` 和 `To` 互换。显而易见，`From` 和 `To` 空间的大小要完全一致。

`GC` 复制算法有很多种，比如 Robert R.Fenichel 和 Jerome C.Yochelson 研究出来的和 C. J.Cheney 研究出来的。下面介绍的是 Cheney 研究出来的算法。

**算法流程**

在 Cheney 的复制算法中，算法流程如下：

初始状态

![image](https://user-images.githubusercontent.com/8407978/160434803-481aea4a-8c56-4f24-9fc1-bd582a58b42b.png)

首先，复制所有从根直接引用的对象，B 和 G。注意，新的 B 引用了 `From` 中的 A，新的 G 还是在引用 `From` 中的 B（为区分，写作B1）和 E

![image](https://user-images.githubusercontent.com/8407978/160434851-e99819a2-a560-435d-8318-f69311262a30.png)

然后，搜索 B1，发现引用了 A，于是把A复制到 `To` 中，同时修正 B 中的指向

![image](https://user-images.githubusercontent.com/8407978/160434896-d8fb6d1d-722b-4dac-a5af-5dbc9351cf8e.png)

接着，搜索 G，把 E 复制到 `To` 中，并且G指向B1的指针换到了 B

![image](https://user-images.githubusercontent.com/8407978/160434915-fd8a8df7-4ced-4840-bc11-ad03cfe74e19.png)

最后，搜索 A 和 E，发现没有引用的对象，清空 `From`，将 `From` 和 `To` 空间互换，复制算法结束

![image](https://user-images.githubusercontent.com/8407978/160434956-5806b4e2-f562-4858-8939-86369132dd21.png)

**优点**

- 吞吐量大
- 不会发生碎片化
- 没有递归调用函数：cheney 的算法中使用迭代的方式进行复制，这意味着没有过多的消耗栈

**缺点**

- 内存空间利用率小，很明显，我们每次只能使用一半的内存空间来分配对象
- 不兼容保守式 GC，因为移动了对象

**触发时机**

`From` 空间没有分块的时候


### 标记-清除算法

本算法分为两个阶段

- 标记阶段： 这个阶段会递归遍历堆中所有的活动对象，打上标记
- 清除阶段： 遍历整个堆中所有对象，把所有没有被标记的对象回收掉，堆越大，回收耗时越长

很明显，经过这两个阶段后，不能利用的内存空得以再次被利用

**优点：**

- 算法实现简单
- 可以适用于保守式 GC 的场景

**缺点：**

- 多次 GC 后会导致内存中出现碎片。碎片化的后果是，即使可用内存的总空间够用，也会因为单个空间不够用导致不能够分配内容（这个时候就要用到下面提到的标记-压缩算法了）

- 假设内存空间一共 5KB，下图中 A、B、C、D、E 各占了 1KB，经历一次 GC 后，B 和 D 被回收，内存空间中剩余 2KB，此时分配一个大小为 2KB 的对象到内存空间中，无法分配，因为剩余的 2KB 空间并不连续

![image](https://user-images.githubusercontent.com/8407978/160435948-1222924f-1a8b-4fd9-9cae-5b4b1fb07c7c.png)

**触发时机**

- 老年代空间中某一个空间没有分块的时候
- 老年代空间中分配了一定数量对象的时候（启动新生代GC时会检查）
- 老年代空间中没有新生代空间大小的分块的时候（这个时候无法保证新生代 GC 时的晋升）

### 标记-压缩算法

**标记阶段**

V8 采用深度优先的方式进行标记，即标记了对象，随后会去标记这个对象的子对象。深度优先遍历时，一般采用递归操作，递归时，自然需要用到栈，在 V8 中，这个栈由V8自行生成。栈所用的空间是新生代的 `From` 空间。因为老年代 GC 之前，必然会执行新生代 GC，这个时候 `From` 空间是空的，既然空都空了，不如就把栈放在这里，不用白不用

**压缩阶段**

压缩前，可以看到老年代空间中存在很多空白小方块，即内存碎片

![image](https://user-images.githubusercontent.com/8407978/160436264-fcf23d15-2336-42a9-9a1c-b9f3a95ee773.png)

压缩时，将内存对象按顺序逐个移动到内存空间的前面

压缩后，可以看到空白小方块已经是连续的了，不存在内存碎片

![image](https://user-images.githubusercontent.com/8407978/160436354-bd34dbe6-4b9e-44bb-b427-71deccf06935.png)

**优点**

有效利用堆，不会像复制算法那样只能利用半个堆，也不会存在内存碎片

**缺点**

在算法过程中，要不断的去移动对象，成本相对于其它算法非常之高

**触发时机**

老年代空间中的碎片到达一定数量的时候


## 参考文章

[垃圾回收器的工作流程](https://blog.poetries.top/browser-working-principle/guide/part3/lesson13.html#%E4%BB%A3%E9%99%85%E5%81%87%E8%AF%B4%E5%92%8C%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86)

[V8 下的垃圾回收机制](https://yuchengkai.cn/docs/frontend/#v8-%E4%B8%8B%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6)

[V8中的垃圾回收算法](https://juejin.cn/post/6931014930019827725)

[V8 引擎垃圾回收与内存分配](https://juejin.cn/post/6909239354418266119)

